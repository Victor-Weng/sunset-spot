/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/suncalc";
exports.ids = ["vendor-chunks/suncalc"];
exports.modules = {

/***/ "(ssr)/./node_modules/suncalc/suncalc.js":
/*!*****************************************!*\
  !*** ./node_modules/suncalc/suncalc.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/*\n (c) 2011-2015, Vladimir Agafonkin\n SunCalc is a JavaScript library for calculating sun/moon position and light phases.\n https://github.com/mourner/suncalc\n*/\n\n(function () { 'use strict';\n\n// shortcuts for easier to read formulas\n\nvar PI   = Math.PI,\n    sin  = Math.sin,\n    cos  = Math.cos,\n    tan  = Math.tan,\n    asin = Math.asin,\n    atan = Math.atan2,\n    acos = Math.acos,\n    rad  = PI / 180;\n\n// sun calculations are based on http://aa.quae.nl/en/reken/zonpositie.html formulas\n\n\n// date/time constants and conversions\n\nvar dayMs = 1000 * 60 * 60 * 24,\n    J1970 = 2440588,\n    J2000 = 2451545;\n\nfunction toJulian(date) { return date.valueOf() / dayMs - 0.5 + J1970; }\nfunction fromJulian(j)  { return new Date((j + 0.5 - J1970) * dayMs); }\nfunction toDays(date)   { return toJulian(date) - J2000; }\n\n\n// general calculations for position\n\nvar e = rad * 23.4397; // obliquity of the Earth\n\nfunction rightAscension(l, b) { return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l)); }\nfunction declination(l, b)    { return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l)); }\n\nfunction azimuth(H, phi, dec)  { return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi)); }\nfunction altitude(H, phi, dec) { return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H)); }\n\nfunction siderealTime(d, lw) { return rad * (280.16 + 360.9856235 * d) - lw; }\n\nfunction astroRefraction(h) {\n    if (h < 0) // the following formula works for positive altitudes only.\n        h = 0; // if h = -0.08901179 a div/0 would occur.\n\n    // formula 16.4 of \"Astronomical Algorithms\" 2nd edition by Jean Meeus (Willmann-Bell, Richmond) 1998.\n    // 1.02 / tan(h + 10.26 / (h + 5.10)) h in degrees, result in arc minutes -> converted to rad:\n    return 0.0002967 / Math.tan(h + 0.00312536 / (h + 0.08901179));\n}\n\n// general sun calculations\n\nfunction solarMeanAnomaly(d) { return rad * (357.5291 + 0.98560028 * d); }\n\nfunction eclipticLongitude(M) {\n\n    var C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 0.0003 * sin(3 * M)), // equation of center\n        P = rad * 102.9372; // perihelion of the Earth\n\n    return M + C + P + PI;\n}\n\nfunction sunCoords(d) {\n\n    var M = solarMeanAnomaly(d),\n        L = eclipticLongitude(M);\n\n    return {\n        dec: declination(L, 0),\n        ra: rightAscension(L, 0)\n    };\n}\n\n\nvar SunCalc = {};\n\n\n// calculates sun position for a given date and latitude/longitude\n\nSunCalc.getPosition = function (date, lat, lng) {\n\n    var lw  = rad * -lng,\n        phi = rad * lat,\n        d   = toDays(date),\n\n        c  = sunCoords(d),\n        H  = siderealTime(d, lw) - c.ra;\n\n    return {\n        azimuth: azimuth(H, phi, c.dec),\n        altitude: altitude(H, phi, c.dec)\n    };\n};\n\n\n// sun times configuration (angle, morning name, evening name)\n\nvar times = SunCalc.times = [\n    [-0.833, 'sunrise',       'sunset'      ],\n    [  -0.3, 'sunriseEnd',    'sunsetStart' ],\n    [    -6, 'dawn',          'dusk'        ],\n    [   -12, 'nauticalDawn',  'nauticalDusk'],\n    [   -18, 'nightEnd',      'night'       ],\n    [     6, 'goldenHourEnd', 'goldenHour'  ]\n];\n\n// adds a custom time to the times config\n\nSunCalc.addTime = function (angle, riseName, setName) {\n    times.push([angle, riseName, setName]);\n};\n\n\n// calculations for sun times\n\nvar J0 = 0.0009;\n\nfunction julianCycle(d, lw) { return Math.round(d - J0 - lw / (2 * PI)); }\n\nfunction approxTransit(Ht, lw, n) { return J0 + (Ht + lw) / (2 * PI) + n; }\nfunction solarTransitJ(ds, M, L)  { return J2000 + ds + 0.0053 * sin(M) - 0.0069 * sin(2 * L); }\n\nfunction hourAngle(h, phi, d) { return acos((sin(h) - sin(phi) * sin(d)) / (cos(phi) * cos(d))); }\nfunction observerAngle(height) { return -2.076 * Math.sqrt(height) / 60; }\n\n// returns set time for the given sun altitude\nfunction getSetJ(h, lw, phi, dec, n, M, L) {\n\n    var w = hourAngle(h, phi, dec),\n        a = approxTransit(w, lw, n);\n    return solarTransitJ(a, M, L);\n}\n\n\n// calculates sun times for a given date, latitude/longitude, and, optionally,\n// the observer height (in meters) relative to the horizon\n\nSunCalc.getTimes = function (date, lat, lng, height) {\n\n    height = height || 0;\n\n    var lw = rad * -lng,\n        phi = rad * lat,\n\n        dh = observerAngle(height),\n\n        d = toDays(date),\n        n = julianCycle(d, lw),\n        ds = approxTransit(0, lw, n),\n\n        M = solarMeanAnomaly(ds),\n        L = eclipticLongitude(M),\n        dec = declination(L, 0),\n\n        Jnoon = solarTransitJ(ds, M, L),\n\n        i, len, time, h0, Jset, Jrise;\n\n\n    var result = {\n        solarNoon: fromJulian(Jnoon),\n        nadir: fromJulian(Jnoon - 0.5)\n    };\n\n    for (i = 0, len = times.length; i < len; i += 1) {\n        time = times[i];\n        h0 = (time[0] + dh) * rad;\n\n        Jset = getSetJ(h0, lw, phi, dec, n, M, L);\n        Jrise = Jnoon - (Jset - Jnoon);\n\n        result[time[1]] = fromJulian(Jrise);\n        result[time[2]] = fromJulian(Jset);\n    }\n\n    return result;\n};\n\n\n// moon calculations, based on http://aa.quae.nl/en/reken/hemelpositie.html formulas\n\nfunction moonCoords(d) { // geocentric ecliptic coordinates of the moon\n\n    var L = rad * (218.316 + 13.176396 * d), // ecliptic longitude\n        M = rad * (134.963 + 13.064993 * d), // mean anomaly\n        F = rad * (93.272 + 13.229350 * d),  // mean distance\n\n        l  = L + rad * 6.289 * sin(M), // longitude\n        b  = rad * 5.128 * sin(F),     // latitude\n        dt = 385001 - 20905 * cos(M);  // distance to the moon in km\n\n    return {\n        ra: rightAscension(l, b),\n        dec: declination(l, b),\n        dist: dt\n    };\n}\n\nSunCalc.getMoonPosition = function (date, lat, lng) {\n\n    var lw  = rad * -lng,\n        phi = rad * lat,\n        d   = toDays(date),\n\n        c = moonCoords(d),\n        H = siderealTime(d, lw) - c.ra,\n        h = altitude(H, phi, c.dec),\n        // formula 14.1 of \"Astronomical Algorithms\" 2nd edition by Jean Meeus (Willmann-Bell, Richmond) 1998.\n        pa = atan(sin(H), tan(phi) * cos(c.dec) - sin(c.dec) * cos(H));\n\n    h = h + astroRefraction(h); // altitude correction for refraction\n\n    return {\n        azimuth: azimuth(H, phi, c.dec),\n        altitude: h,\n        distance: c.dist,\n        parallacticAngle: pa\n    };\n};\n\n\n// calculations for illumination parameters of the moon,\n// based on http://idlastro.gsfc.nasa.gov/ftp/pro/astro/mphase.pro formulas and\n// Chapter 48 of \"Astronomical Algorithms\" 2nd edition by Jean Meeus (Willmann-Bell, Richmond) 1998.\n\nSunCalc.getMoonIllumination = function (date) {\n\n    var d = toDays(date || new Date()),\n        s = sunCoords(d),\n        m = moonCoords(d),\n\n        sdist = 149598000, // distance from Earth to Sun in km\n\n        phi = acos(sin(s.dec) * sin(m.dec) + cos(s.dec) * cos(m.dec) * cos(s.ra - m.ra)),\n        inc = atan(sdist * sin(phi), m.dist - sdist * cos(phi)),\n        angle = atan(cos(s.dec) * sin(s.ra - m.ra), sin(s.dec) * cos(m.dec) -\n                cos(s.dec) * sin(m.dec) * cos(s.ra - m.ra));\n\n    return {\n        fraction: (1 + cos(inc)) / 2,\n        phase: 0.5 + 0.5 * inc * (angle < 0 ? -1 : 1) / Math.PI,\n        angle: angle\n    };\n};\n\n\nfunction hoursLater(date, h) {\n    return new Date(date.valueOf() + h * dayMs / 24);\n}\n\n// calculations for moon rise/set times are based on http://www.stargazing.net/kepler/moonrise.html article\n\nSunCalc.getMoonTimes = function (date, lat, lng, inUTC) {\n    var t = new Date(date);\n    if (inUTC) t.setUTCHours(0, 0, 0, 0);\n    else t.setHours(0, 0, 0, 0);\n\n    var hc = 0.133 * rad,\n        h0 = SunCalc.getMoonPosition(t, lat, lng).altitude - hc,\n        h1, h2, rise, set, a, b, xe, ye, d, roots, x1, x2, dx;\n\n    // go in 2-hour chunks, each time seeing if a 3-point quadratic curve crosses zero (which means rise or set)\n    for (var i = 1; i <= 24; i += 2) {\n        h1 = SunCalc.getMoonPosition(hoursLater(t, i), lat, lng).altitude - hc;\n        h2 = SunCalc.getMoonPosition(hoursLater(t, i + 1), lat, lng).altitude - hc;\n\n        a = (h0 + h2) / 2 - h1;\n        b = (h2 - h0) / 2;\n        xe = -b / (2 * a);\n        ye = (a * xe + b) * xe + h1;\n        d = b * b - 4 * a * h1;\n        roots = 0;\n\n        if (d >= 0) {\n            dx = Math.sqrt(d) / (Math.abs(a) * 2);\n            x1 = xe - dx;\n            x2 = xe + dx;\n            if (Math.abs(x1) <= 1) roots++;\n            if (Math.abs(x2) <= 1) roots++;\n            if (x1 < -1) x1 = x2;\n        }\n\n        if (roots === 1) {\n            if (h0 < 0) rise = i + x1;\n            else set = i + x1;\n\n        } else if (roots === 2) {\n            rise = i + (ye < 0 ? x2 : x1);\n            set = i + (ye < 0 ? x1 : x2);\n        }\n\n        if (rise && set) break;\n\n        h0 = h2;\n    }\n\n    var result = {};\n\n    if (rise) result.rise = hoursLater(t, rise);\n    if (set) result.set = hoursLater(t, set);\n\n    if (!rise && !set) result[ye > 0 ? 'alwaysUp' : 'alwaysDown'] = true;\n\n    return result;\n};\n\n\n// export as Node module / AMD module / browser variable\nif (true) module.exports = SunCalc;\nelse {}\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3VuY2FsYy9zdW5jYWxjLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7OztBQUcxQjs7QUFFQSx1QkFBdUI7O0FBRXZCLGdDQUFnQztBQUNoQyxnQ0FBZ0M7O0FBRWhDLGlDQUFpQztBQUNqQyxpQ0FBaUM7O0FBRWpDLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUEsOEJBQThCOztBQUU5QixvQ0FBb0M7QUFDcEMsb0NBQW9DOztBQUVwQyxnQ0FBZ0M7QUFDaEMsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLElBQUksSUFBNEQ7QUFDaEUsS0FBSyxFQUN5Qjs7QUFFOUIsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2hhbmhlZWxlZS9EZXNrdG9wL3N1bnNldC1zcG90L25vZGVfbW9kdWxlcy9zdW5jYWxjL3N1bmNhbGMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAoYykgMjAxMS0yMDE1LCBWbGFkaW1pciBBZ2Fmb25raW5cbiBTdW5DYWxjIGlzIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBjYWxjdWxhdGluZyBzdW4vbW9vbiBwb3NpdGlvbiBhbmQgbGlnaHQgcGhhc2VzLlxuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3N1bmNhbGNcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gc2hvcnRjdXRzIGZvciBlYXNpZXIgdG8gcmVhZCBmb3JtdWxhc1xuXG52YXIgUEkgICA9IE1hdGguUEksXG4gICAgc2luICA9IE1hdGguc2luLFxuICAgIGNvcyAgPSBNYXRoLmNvcyxcbiAgICB0YW4gID0gTWF0aC50YW4sXG4gICAgYXNpbiA9IE1hdGguYXNpbixcbiAgICBhdGFuID0gTWF0aC5hdGFuMixcbiAgICBhY29zID0gTWF0aC5hY29zLFxuICAgIHJhZCAgPSBQSSAvIDE4MDtcblxuLy8gc3VuIGNhbGN1bGF0aW9ucyBhcmUgYmFzZWQgb24gaHR0cDovL2FhLnF1YWUubmwvZW4vcmVrZW4vem9ucG9zaXRpZS5odG1sIGZvcm11bGFzXG5cblxuLy8gZGF0ZS90aW1lIGNvbnN0YW50cyBhbmQgY29udmVyc2lvbnNcblxudmFyIGRheU1zID0gMTAwMCAqIDYwICogNjAgKiAyNCxcbiAgICBKMTk3MCA9IDI0NDA1ODgsXG4gICAgSjIwMDAgPSAyNDUxNTQ1O1xuXG5mdW5jdGlvbiB0b0p1bGlhbihkYXRlKSB7IHJldHVybiBkYXRlLnZhbHVlT2YoKSAvIGRheU1zIC0gMC41ICsgSjE5NzA7IH1cbmZ1bmN0aW9uIGZyb21KdWxpYW4oaikgIHsgcmV0dXJuIG5ldyBEYXRlKChqICsgMC41IC0gSjE5NzApICogZGF5TXMpOyB9XG5mdW5jdGlvbiB0b0RheXMoZGF0ZSkgICB7IHJldHVybiB0b0p1bGlhbihkYXRlKSAtIEoyMDAwOyB9XG5cblxuLy8gZ2VuZXJhbCBjYWxjdWxhdGlvbnMgZm9yIHBvc2l0aW9uXG5cbnZhciBlID0gcmFkICogMjMuNDM5NzsgLy8gb2JsaXF1aXR5IG9mIHRoZSBFYXJ0aFxuXG5mdW5jdGlvbiByaWdodEFzY2Vuc2lvbihsLCBiKSB7IHJldHVybiBhdGFuKHNpbihsKSAqIGNvcyhlKSAtIHRhbihiKSAqIHNpbihlKSwgY29zKGwpKTsgfVxuZnVuY3Rpb24gZGVjbGluYXRpb24obCwgYikgICAgeyByZXR1cm4gYXNpbihzaW4oYikgKiBjb3MoZSkgKyBjb3MoYikgKiBzaW4oZSkgKiBzaW4obCkpOyB9XG5cbmZ1bmN0aW9uIGF6aW11dGgoSCwgcGhpLCBkZWMpICB7IHJldHVybiBhdGFuKHNpbihIKSwgY29zKEgpICogc2luKHBoaSkgLSB0YW4oZGVjKSAqIGNvcyhwaGkpKTsgfVxuZnVuY3Rpb24gYWx0aXR1ZGUoSCwgcGhpLCBkZWMpIHsgcmV0dXJuIGFzaW4oc2luKHBoaSkgKiBzaW4oZGVjKSArIGNvcyhwaGkpICogY29zKGRlYykgKiBjb3MoSCkpOyB9XG5cbmZ1bmN0aW9uIHNpZGVyZWFsVGltZShkLCBsdykgeyByZXR1cm4gcmFkICogKDI4MC4xNiArIDM2MC45ODU2MjM1ICogZCkgLSBsdzsgfVxuXG5mdW5jdGlvbiBhc3Ryb1JlZnJhY3Rpb24oaCkge1xuICAgIGlmIChoIDwgMCkgLy8gdGhlIGZvbGxvd2luZyBmb3JtdWxhIHdvcmtzIGZvciBwb3NpdGl2ZSBhbHRpdHVkZXMgb25seS5cbiAgICAgICAgaCA9IDA7IC8vIGlmIGggPSAtMC4wODkwMTE3OSBhIGRpdi8wIHdvdWxkIG9jY3VyLlxuXG4gICAgLy8gZm9ybXVsYSAxNi40IG9mIFwiQXN0cm9ub21pY2FsIEFsZ29yaXRobXNcIiAybmQgZWRpdGlvbiBieSBKZWFuIE1lZXVzIChXaWxsbWFubi1CZWxsLCBSaWNobW9uZCkgMTk5OC5cbiAgICAvLyAxLjAyIC8gdGFuKGggKyAxMC4yNiAvIChoICsgNS4xMCkpIGggaW4gZGVncmVlcywgcmVzdWx0IGluIGFyYyBtaW51dGVzIC0+IGNvbnZlcnRlZCB0byByYWQ6XG4gICAgcmV0dXJuIDAuMDAwMjk2NyAvIE1hdGgudGFuKGggKyAwLjAwMzEyNTM2IC8gKGggKyAwLjA4OTAxMTc5KSk7XG59XG5cbi8vIGdlbmVyYWwgc3VuIGNhbGN1bGF0aW9uc1xuXG5mdW5jdGlvbiBzb2xhck1lYW5Bbm9tYWx5KGQpIHsgcmV0dXJuIHJhZCAqICgzNTcuNTI5MSArIDAuOTg1NjAwMjggKiBkKTsgfVxuXG5mdW5jdGlvbiBlY2xpcHRpY0xvbmdpdHVkZShNKSB7XG5cbiAgICB2YXIgQyA9IHJhZCAqICgxLjkxNDggKiBzaW4oTSkgKyAwLjAyICogc2luKDIgKiBNKSArIDAuMDAwMyAqIHNpbigzICogTSkpLCAvLyBlcXVhdGlvbiBvZiBjZW50ZXJcbiAgICAgICAgUCA9IHJhZCAqIDEwMi45MzcyOyAvLyBwZXJpaGVsaW9uIG9mIHRoZSBFYXJ0aFxuXG4gICAgcmV0dXJuIE0gKyBDICsgUCArIFBJO1xufVxuXG5mdW5jdGlvbiBzdW5Db29yZHMoZCkge1xuXG4gICAgdmFyIE0gPSBzb2xhck1lYW5Bbm9tYWx5KGQpLFxuICAgICAgICBMID0gZWNsaXB0aWNMb25naXR1ZGUoTSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWM6IGRlY2xpbmF0aW9uKEwsIDApLFxuICAgICAgICByYTogcmlnaHRBc2NlbnNpb24oTCwgMClcbiAgICB9O1xufVxuXG5cbnZhciBTdW5DYWxjID0ge307XG5cblxuLy8gY2FsY3VsYXRlcyBzdW4gcG9zaXRpb24gZm9yIGEgZ2l2ZW4gZGF0ZSBhbmQgbGF0aXR1ZGUvbG9uZ2l0dWRlXG5cblN1bkNhbGMuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoZGF0ZSwgbGF0LCBsbmcpIHtcblxuICAgIHZhciBsdyAgPSByYWQgKiAtbG5nLFxuICAgICAgICBwaGkgPSByYWQgKiBsYXQsXG4gICAgICAgIGQgICA9IHRvRGF5cyhkYXRlKSxcblxuICAgICAgICBjICA9IHN1bkNvb3JkcyhkKSxcbiAgICAgICAgSCAgPSBzaWRlcmVhbFRpbWUoZCwgbHcpIC0gYy5yYTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGF6aW11dGg6IGF6aW11dGgoSCwgcGhpLCBjLmRlYyksXG4gICAgICAgIGFsdGl0dWRlOiBhbHRpdHVkZShILCBwaGksIGMuZGVjKVxuICAgIH07XG59O1xuXG5cbi8vIHN1biB0aW1lcyBjb25maWd1cmF0aW9uIChhbmdsZSwgbW9ybmluZyBuYW1lLCBldmVuaW5nIG5hbWUpXG5cbnZhciB0aW1lcyA9IFN1bkNhbGMudGltZXMgPSBbXG4gICAgWy0wLjgzMywgJ3N1bnJpc2UnLCAgICAgICAnc3Vuc2V0JyAgICAgIF0sXG4gICAgWyAgLTAuMywgJ3N1bnJpc2VFbmQnLCAgICAnc3Vuc2V0U3RhcnQnIF0sXG4gICAgWyAgICAtNiwgJ2Rhd24nLCAgICAgICAgICAnZHVzaycgICAgICAgIF0sXG4gICAgWyAgIC0xMiwgJ25hdXRpY2FsRGF3bicsICAnbmF1dGljYWxEdXNrJ10sXG4gICAgWyAgIC0xOCwgJ25pZ2h0RW5kJywgICAgICAnbmlnaHQnICAgICAgIF0sXG4gICAgWyAgICAgNiwgJ2dvbGRlbkhvdXJFbmQnLCAnZ29sZGVuSG91cicgIF1cbl07XG5cbi8vIGFkZHMgYSBjdXN0b20gdGltZSB0byB0aGUgdGltZXMgY29uZmlnXG5cblN1bkNhbGMuYWRkVGltZSA9IGZ1bmN0aW9uIChhbmdsZSwgcmlzZU5hbWUsIHNldE5hbWUpIHtcbiAgICB0aW1lcy5wdXNoKFthbmdsZSwgcmlzZU5hbWUsIHNldE5hbWVdKTtcbn07XG5cblxuLy8gY2FsY3VsYXRpb25zIGZvciBzdW4gdGltZXNcblxudmFyIEowID0gMC4wMDA5O1xuXG5mdW5jdGlvbiBqdWxpYW5DeWNsZShkLCBsdykgeyByZXR1cm4gTWF0aC5yb3VuZChkIC0gSjAgLSBsdyAvICgyICogUEkpKTsgfVxuXG5mdW5jdGlvbiBhcHByb3hUcmFuc2l0KEh0LCBsdywgbikgeyByZXR1cm4gSjAgKyAoSHQgKyBsdykgLyAoMiAqIFBJKSArIG47IH1cbmZ1bmN0aW9uIHNvbGFyVHJhbnNpdEooZHMsIE0sIEwpICB7IHJldHVybiBKMjAwMCArIGRzICsgMC4wMDUzICogc2luKE0pIC0gMC4wMDY5ICogc2luKDIgKiBMKTsgfVxuXG5mdW5jdGlvbiBob3VyQW5nbGUoaCwgcGhpLCBkKSB7IHJldHVybiBhY29zKChzaW4oaCkgLSBzaW4ocGhpKSAqIHNpbihkKSkgLyAoY29zKHBoaSkgKiBjb3MoZCkpKTsgfVxuZnVuY3Rpb24gb2JzZXJ2ZXJBbmdsZShoZWlnaHQpIHsgcmV0dXJuIC0yLjA3NiAqIE1hdGguc3FydChoZWlnaHQpIC8gNjA7IH1cblxuLy8gcmV0dXJucyBzZXQgdGltZSBmb3IgdGhlIGdpdmVuIHN1biBhbHRpdHVkZVxuZnVuY3Rpb24gZ2V0U2V0SihoLCBsdywgcGhpLCBkZWMsIG4sIE0sIEwpIHtcblxuICAgIHZhciB3ID0gaG91ckFuZ2xlKGgsIHBoaSwgZGVjKSxcbiAgICAgICAgYSA9IGFwcHJveFRyYW5zaXQodywgbHcsIG4pO1xuICAgIHJldHVybiBzb2xhclRyYW5zaXRKKGEsIE0sIEwpO1xufVxuXG5cbi8vIGNhbGN1bGF0ZXMgc3VuIHRpbWVzIGZvciBhIGdpdmVuIGRhdGUsIGxhdGl0dWRlL2xvbmdpdHVkZSwgYW5kLCBvcHRpb25hbGx5LFxuLy8gdGhlIG9ic2VydmVyIGhlaWdodCAoaW4gbWV0ZXJzKSByZWxhdGl2ZSB0byB0aGUgaG9yaXpvblxuXG5TdW5DYWxjLmdldFRpbWVzID0gZnVuY3Rpb24gKGRhdGUsIGxhdCwgbG5nLCBoZWlnaHQpIHtcblxuICAgIGhlaWdodCA9IGhlaWdodCB8fCAwO1xuXG4gICAgdmFyIGx3ID0gcmFkICogLWxuZyxcbiAgICAgICAgcGhpID0gcmFkICogbGF0LFxuXG4gICAgICAgIGRoID0gb2JzZXJ2ZXJBbmdsZShoZWlnaHQpLFxuXG4gICAgICAgIGQgPSB0b0RheXMoZGF0ZSksXG4gICAgICAgIG4gPSBqdWxpYW5DeWNsZShkLCBsdyksXG4gICAgICAgIGRzID0gYXBwcm94VHJhbnNpdCgwLCBsdywgbiksXG5cbiAgICAgICAgTSA9IHNvbGFyTWVhbkFub21hbHkoZHMpLFxuICAgICAgICBMID0gZWNsaXB0aWNMb25naXR1ZGUoTSksXG4gICAgICAgIGRlYyA9IGRlY2xpbmF0aW9uKEwsIDApLFxuXG4gICAgICAgIEpub29uID0gc29sYXJUcmFuc2l0SihkcywgTSwgTCksXG5cbiAgICAgICAgaSwgbGVuLCB0aW1lLCBoMCwgSnNldCwgSnJpc2U7XG5cblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHNvbGFyTm9vbjogZnJvbUp1bGlhbihKbm9vbiksXG4gICAgICAgIG5hZGlyOiBmcm9tSnVsaWFuKEpub29uIC0gMC41KVxuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aW1lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aW1lID0gdGltZXNbaV07XG4gICAgICAgIGgwID0gKHRpbWVbMF0gKyBkaCkgKiByYWQ7XG5cbiAgICAgICAgSnNldCA9IGdldFNldEooaDAsIGx3LCBwaGksIGRlYywgbiwgTSwgTCk7XG4gICAgICAgIEpyaXNlID0gSm5vb24gLSAoSnNldCAtIEpub29uKTtcblxuICAgICAgICByZXN1bHRbdGltZVsxXV0gPSBmcm9tSnVsaWFuKEpyaXNlKTtcbiAgICAgICAgcmVzdWx0W3RpbWVbMl1dID0gZnJvbUp1bGlhbihKc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyBtb29uIGNhbGN1bGF0aW9ucywgYmFzZWQgb24gaHR0cDovL2FhLnF1YWUubmwvZW4vcmVrZW4vaGVtZWxwb3NpdGllLmh0bWwgZm9ybXVsYXNcblxuZnVuY3Rpb24gbW9vbkNvb3JkcyhkKSB7IC8vIGdlb2NlbnRyaWMgZWNsaXB0aWMgY29vcmRpbmF0ZXMgb2YgdGhlIG1vb25cblxuICAgIHZhciBMID0gcmFkICogKDIxOC4zMTYgKyAxMy4xNzYzOTYgKiBkKSwgLy8gZWNsaXB0aWMgbG9uZ2l0dWRlXG4gICAgICAgIE0gPSByYWQgKiAoMTM0Ljk2MyArIDEzLjA2NDk5MyAqIGQpLCAvLyBtZWFuIGFub21hbHlcbiAgICAgICAgRiA9IHJhZCAqICg5My4yNzIgKyAxMy4yMjkzNTAgKiBkKSwgIC8vIG1lYW4gZGlzdGFuY2VcblxuICAgICAgICBsICA9IEwgKyByYWQgKiA2LjI4OSAqIHNpbihNKSwgLy8gbG9uZ2l0dWRlXG4gICAgICAgIGIgID0gcmFkICogNS4xMjggKiBzaW4oRiksICAgICAvLyBsYXRpdHVkZVxuICAgICAgICBkdCA9IDM4NTAwMSAtIDIwOTA1ICogY29zKE0pOyAgLy8gZGlzdGFuY2UgdG8gdGhlIG1vb24gaW4ga21cblxuICAgIHJldHVybiB7XG4gICAgICAgIHJhOiByaWdodEFzY2Vuc2lvbihsLCBiKSxcbiAgICAgICAgZGVjOiBkZWNsaW5hdGlvbihsLCBiKSxcbiAgICAgICAgZGlzdDogZHRcbiAgICB9O1xufVxuXG5TdW5DYWxjLmdldE1vb25Qb3NpdGlvbiA9IGZ1bmN0aW9uIChkYXRlLCBsYXQsIGxuZykge1xuXG4gICAgdmFyIGx3ICA9IHJhZCAqIC1sbmcsXG4gICAgICAgIHBoaSA9IHJhZCAqIGxhdCxcbiAgICAgICAgZCAgID0gdG9EYXlzKGRhdGUpLFxuXG4gICAgICAgIGMgPSBtb29uQ29vcmRzKGQpLFxuICAgICAgICBIID0gc2lkZXJlYWxUaW1lKGQsIGx3KSAtIGMucmEsXG4gICAgICAgIGggPSBhbHRpdHVkZShILCBwaGksIGMuZGVjKSxcbiAgICAgICAgLy8gZm9ybXVsYSAxNC4xIG9mIFwiQXN0cm9ub21pY2FsIEFsZ29yaXRobXNcIiAybmQgZWRpdGlvbiBieSBKZWFuIE1lZXVzIChXaWxsbWFubi1CZWxsLCBSaWNobW9uZCkgMTk5OC5cbiAgICAgICAgcGEgPSBhdGFuKHNpbihIKSwgdGFuKHBoaSkgKiBjb3MoYy5kZWMpIC0gc2luKGMuZGVjKSAqIGNvcyhIKSk7XG5cbiAgICBoID0gaCArIGFzdHJvUmVmcmFjdGlvbihoKTsgLy8gYWx0aXR1ZGUgY29ycmVjdGlvbiBmb3IgcmVmcmFjdGlvblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXppbXV0aDogYXppbXV0aChILCBwaGksIGMuZGVjKSxcbiAgICAgICAgYWx0aXR1ZGU6IGgsXG4gICAgICAgIGRpc3RhbmNlOiBjLmRpc3QsXG4gICAgICAgIHBhcmFsbGFjdGljQW5nbGU6IHBhXG4gICAgfTtcbn07XG5cblxuLy8gY2FsY3VsYXRpb25zIGZvciBpbGx1bWluYXRpb24gcGFyYW1ldGVycyBvZiB0aGUgbW9vbixcbi8vIGJhc2VkIG9uIGh0dHA6Ly9pZGxhc3Ryby5nc2ZjLm5hc2EuZ292L2Z0cC9wcm8vYXN0cm8vbXBoYXNlLnBybyBmb3JtdWxhcyBhbmRcbi8vIENoYXB0ZXIgNDggb2YgXCJBc3Ryb25vbWljYWwgQWxnb3JpdGhtc1wiIDJuZCBlZGl0aW9uIGJ5IEplYW4gTWVldXMgKFdpbGxtYW5uLUJlbGwsIFJpY2htb25kKSAxOTk4LlxuXG5TdW5DYWxjLmdldE1vb25JbGx1bWluYXRpb24gPSBmdW5jdGlvbiAoZGF0ZSkge1xuXG4gICAgdmFyIGQgPSB0b0RheXMoZGF0ZSB8fCBuZXcgRGF0ZSgpKSxcbiAgICAgICAgcyA9IHN1bkNvb3JkcyhkKSxcbiAgICAgICAgbSA9IG1vb25Db29yZHMoZCksXG5cbiAgICAgICAgc2Rpc3QgPSAxNDk1OTgwMDAsIC8vIGRpc3RhbmNlIGZyb20gRWFydGggdG8gU3VuIGluIGttXG5cbiAgICAgICAgcGhpID0gYWNvcyhzaW4ocy5kZWMpICogc2luKG0uZGVjKSArIGNvcyhzLmRlYykgKiBjb3MobS5kZWMpICogY29zKHMucmEgLSBtLnJhKSksXG4gICAgICAgIGluYyA9IGF0YW4oc2Rpc3QgKiBzaW4ocGhpKSwgbS5kaXN0IC0gc2Rpc3QgKiBjb3MocGhpKSksXG4gICAgICAgIGFuZ2xlID0gYXRhbihjb3Mocy5kZWMpICogc2luKHMucmEgLSBtLnJhKSwgc2luKHMuZGVjKSAqIGNvcyhtLmRlYykgLVxuICAgICAgICAgICAgICAgIGNvcyhzLmRlYykgKiBzaW4obS5kZWMpICogY29zKHMucmEgLSBtLnJhKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmcmFjdGlvbjogKDEgKyBjb3MoaW5jKSkgLyAyLFxuICAgICAgICBwaGFzZTogMC41ICsgMC41ICogaW5jICogKGFuZ2xlIDwgMCA/IC0xIDogMSkgLyBNYXRoLlBJLFxuICAgICAgICBhbmdsZTogYW5nbGVcbiAgICB9O1xufTtcblxuXG5mdW5jdGlvbiBob3Vyc0xhdGVyKGRhdGUsIGgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkgKyBoICogZGF5TXMgLyAyNCk7XG59XG5cbi8vIGNhbGN1bGF0aW9ucyBmb3IgbW9vbiByaXNlL3NldCB0aW1lcyBhcmUgYmFzZWQgb24gaHR0cDovL3d3dy5zdGFyZ2F6aW5nLm5ldC9rZXBsZXIvbW9vbnJpc2UuaHRtbCBhcnRpY2xlXG5cblN1bkNhbGMuZ2V0TW9vblRpbWVzID0gZnVuY3Rpb24gKGRhdGUsIGxhdCwgbG5nLCBpblVUQykge1xuICAgIHZhciB0ID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgaWYgKGluVVRDKSB0LnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIGVsc2UgdC5zZXRIb3VycygwLCAwLCAwLCAwKTtcblxuICAgIHZhciBoYyA9IDAuMTMzICogcmFkLFxuICAgICAgICBoMCA9IFN1bkNhbGMuZ2V0TW9vblBvc2l0aW9uKHQsIGxhdCwgbG5nKS5hbHRpdHVkZSAtIGhjLFxuICAgICAgICBoMSwgaDIsIHJpc2UsIHNldCwgYSwgYiwgeGUsIHllLCBkLCByb290cywgeDEsIHgyLCBkeDtcblxuICAgIC8vIGdvIGluIDItaG91ciBjaHVua3MsIGVhY2ggdGltZSBzZWVpbmcgaWYgYSAzLXBvaW50IHF1YWRyYXRpYyBjdXJ2ZSBjcm9zc2VzIHplcm8gKHdoaWNoIG1lYW5zIHJpc2Ugb3Igc2V0KVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDI0OyBpICs9IDIpIHtcbiAgICAgICAgaDEgPSBTdW5DYWxjLmdldE1vb25Qb3NpdGlvbihob3Vyc0xhdGVyKHQsIGkpLCBsYXQsIGxuZykuYWx0aXR1ZGUgLSBoYztcbiAgICAgICAgaDIgPSBTdW5DYWxjLmdldE1vb25Qb3NpdGlvbihob3Vyc0xhdGVyKHQsIGkgKyAxKSwgbGF0LCBsbmcpLmFsdGl0dWRlIC0gaGM7XG5cbiAgICAgICAgYSA9IChoMCArIGgyKSAvIDIgLSBoMTtcbiAgICAgICAgYiA9IChoMiAtIGgwKSAvIDI7XG4gICAgICAgIHhlID0gLWIgLyAoMiAqIGEpO1xuICAgICAgICB5ZSA9IChhICogeGUgKyBiKSAqIHhlICsgaDE7XG4gICAgICAgIGQgPSBiICogYiAtIDQgKiBhICogaDE7XG4gICAgICAgIHJvb3RzID0gMDtcblxuICAgICAgICBpZiAoZCA+PSAwKSB7XG4gICAgICAgICAgICBkeCA9IE1hdGguc3FydChkKSAvIChNYXRoLmFicyhhKSAqIDIpO1xuICAgICAgICAgICAgeDEgPSB4ZSAtIGR4O1xuICAgICAgICAgICAgeDIgPSB4ZSArIGR4O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgxKSA8PSAxKSByb290cysrO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgyKSA8PSAxKSByb290cysrO1xuICAgICAgICAgICAgaWYgKHgxIDwgLTEpIHgxID0geDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdHMgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChoMCA8IDApIHJpc2UgPSBpICsgeDE7XG4gICAgICAgICAgICBlbHNlIHNldCA9IGkgKyB4MTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJvb3RzID09PSAyKSB7XG4gICAgICAgICAgICByaXNlID0gaSArICh5ZSA8IDAgPyB4MiA6IHgxKTtcbiAgICAgICAgICAgIHNldCA9IGkgKyAoeWUgPCAwID8geDEgOiB4Mik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmlzZSAmJiBzZXQpIGJyZWFrO1xuXG4gICAgICAgIGgwID0gaDI7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgaWYgKHJpc2UpIHJlc3VsdC5yaXNlID0gaG91cnNMYXRlcih0LCByaXNlKTtcbiAgICBpZiAoc2V0KSByZXN1bHQuc2V0ID0gaG91cnNMYXRlcih0LCBzZXQpO1xuXG4gICAgaWYgKCFyaXNlICYmICFzZXQpIHJlc3VsdFt5ZSA+IDAgPyAnYWx3YXlzVXAnIDogJ2Fsd2F5c0Rvd24nXSA9IHRydWU7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyBleHBvcnQgYXMgTm9kZSBtb2R1bGUgLyBBTUQgbW9kdWxlIC8gYnJvd3NlciB2YXJpYWJsZVxuaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBTdW5DYWxjO1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoU3VuQ2FsYyk7XG5lbHNlIHdpbmRvdy5TdW5DYWxjID0gU3VuQ2FsYztcblxufSgpKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/suncalc/suncalc.js\n");

/***/ })

};
;